name: Enhanced AI Code Review

on:
  pull_request:
    branches: [main, develop]

jobs:
  ai-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    
    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
      
      - name: Fetch base branch
        run: |
          git fetch origin ${{ github.base_ref }}
          git branch -a
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install
        run: npm ci
      
      - name: Enhanced AI Review
        id: review
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_BASE_REF: ${{ github.base_ref }}
          GITHUB_HEAD_REF: ${{ github.head_ref }}
        run: npm run ai-review || true
        continue-on-error: true
      
      - name: Add labels based on review
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const fs = require('fs');
            let results;
            try {
              results = JSON.parse(fs.readFileSync('ai-review-results.json', 'utf8'));
            } catch (e) {
              return;
            }
            
            // Remove old AI labels
            const labels = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            for (const label of labels.data) {
              if (label.name.startsWith('ai-review:')) {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: label.name
                });
              }
            }
            
            // Add new label based on results
            let labelName = '';
            if (results.criticalCount > 0) {
              labelName = 'ai-review:critical-issues';
            } else if (results.errorCount > 0) {
              labelName = 'ai-review:needs-fixes';
            } else if (results.warningCount > 0) {
              labelName = 'ai-review:approved-with-warnings';
            } else if (results.filesReviewed > 0) {
              labelName = 'ai-review:approved';
            }
            
            if (labelName) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: [labelName]
                });
              } catch (e) {
                console.log('Could not add label (might not exist yet)');
              }
            }

      - name: Post Review Comments
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const fs = require('fs');
            let results;
            try {
              results = JSON.parse(fs.readFileSync('ai-review-results.json', 'utf8'));
            } catch (e) {
              console.log('No results file');
              return;
            }
            
            const sev = { critical: 'ðŸ”´', error: 'ðŸŸ ', warning: 'ðŸŸ¡', info: 'ðŸ”µ' };
            const lab = { critical: 'CRITICAL', error: 'ERROR', warning: 'WARNING', info: 'INFO' };
            
            // Create review comments
            let comments = [];
            if (results.issues && results.issues.length > 0) {
              for (const fd of results.issues) {
                for (const iss of fd.issues) {
                  let body = sev[iss.severity] + ' **' + lab[iss.severity] + ': ' + (iss.category || 'GENERAL').toUpperCase() + '**\n\n';
                  body += '**Problem:** ' + iss.issue + '\n\n';
                  if (iss.code) body += '**Code:**\n```svelte\n' + iss.code + '\n```\n\n';
                  if (iss.suggestion) body += '**Fix:**\n```svelte\n' + iss.suggestion + '\n```\n\n';
                  if (iss.impact) body += '**Impact:** ' + iss.impact + '\n\n';
                  body += '\n_AI Review by Claude_';
                  comments.push({ path: fd.file, line: iss.line, body });
                }
              }
            }
            
            // Determine status (no APPROVE - GitHub Actions can't approve)
            let reviewEvent = 'COMMENT';
            let body = '## AI Code Review Results\n\n';
            
            if (results.filesReviewed === 0) {
              body += 'âœ… **No Svelte files changed**\n\n';
              body += 'No review needed for this PR.';
            } else if (results.criticalCount > 0) {
              reviewEvent = 'REQUEST_CHANGES';
              body += 'ðŸ”´ **CRITICAL ISSUES FOUND**\n\n';
              body += 'âš ï¸ Human review required before merging.\n\n';
              body += '**Summary:**\n';
              body += '- Files Reviewed: ' + results.filesReviewed + '\n';
              body += '- Critical: ' + results.criticalCount + '\n';
              body += '- Errors: ' + results.errorCount + '\n';
              body += '- Warnings: ' + results.warningCount + '\n';
            } else if (results.errorCount > 0) {
              body += 'ðŸŸ  **Errors Found**\n\n';
              body += '**Summary:**\n';
              body += '- Files Reviewed: ' + results.filesReviewed + '\n';
              body += '- Errors: ' + results.errorCount + '\n';
              body += '- Warnings: ' + results.warningCount + '\n';
            } else if (results.warningCount > 0) {
              body += 'ðŸŸ¡ **Minor Warnings**\n\n';
              body += 'âœ… Code is acceptable for merging.\n\n';
              body += '**Summary:**\n';
              body += '- Files Reviewed: ' + results.filesReviewed + '\n';
              body += '- Warnings: ' + results.warningCount + '\n';
              body += '- Info: ' + results.infoCount + '\n';
            } else {
              body += 'âœ… **All Checks Passed!**\n\n';
              body += '**Summary:**\n';
              body += '- Files Reviewed: ' + results.filesReviewed + '\n';
              body += '- No issues found\n';
            }
            
            if (results.changedFiles && results.changedFiles.length > 0) {
              body += '\n**Files Reviewed:**\n';
              results.changedFiles.forEach(f => body += '- `' + f + '`\n');
            }
            
            if (results.analytics && results.analytics.insights) {
              body += '\n---\n' + results.analytics.insights;
            }
            
            // Post review
            try {
              if (comments.length > 0) {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.issue.number,
                  event: reviewEvent,
                  body: body,
                  comments: comments
                });
              } else {
                // No inline comments, just post summary
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: body
                });
              }
              console.log('Review posted successfully');
            } catch (err) {
              console.log('Error posting review:', err.message);
              
              // Fallback: post as regular comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }