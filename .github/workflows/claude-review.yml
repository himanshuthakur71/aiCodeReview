name: AI Code Review

on:
  pull_request:
    branches: [main, develop]

jobs:
  ai-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    
    steps:
      - name: Generate App Token
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
      
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
      
      - name: Fetch base branch
        run: |
          git fetch origin ${{ github.base_ref }}:refs/remotes/origin/${{ github.base_ref }}
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install
        run: npm ci
      
      - name: Download Previous Review
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: previous-review
          path: .
      
      - name: AI Review
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_EVENT_NAME: pull_request
          GITHUB_BASE_REF: ${{ github.base_ref }}
          GITHUB_HEAD_REF: ${{ github.head_ref }}
          PR_BASE_SHA: ${{ github.event.pull_request.base.sha }}
          PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: npm run ai-review || true
      
      - name: Debug Results
        run: |
          echo "=== AI Review Results ==="
          cat ai-review-results.json || echo "No results file"
      
      - name: Post Inline Comments
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.generate-token.outputs.token }}
          script: |
            const fs = require('fs');
            let results;
            
            try {
              const content = fs.readFileSync('ai-review-results.json', 'utf8');
              console.log('Raw results:', content);
              results = JSON.parse(content);
            } catch (e) {
              console.log('Error reading results:', e.message);
              return;
            }
            
            console.log('Parsed results:', JSON.stringify(results, null, 2));
            
            const icons = {
              critical: 'üî¥',
              error: 'üü†', 
              warning: 'üü°',
              info: 'üîµ'
            };
            
            // Get existing comments
            let existingComments = [];
            try {
              const comments = await github.rest.pulls.listReviewComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });
              existingComments = comments.data || [];
              console.log('Found', existingComments.length, 'existing comments');
            } catch (e) {
              console.log('Could not fetch existing comments:', e.message);
            }
            
            // Build map of current issues
            const currentIssuesMap = new Map();
            if (results.issues && Array.isArray(results.issues)) {
              results.issues.forEach(fileData => {
                console.log('Processing file:', fileData.file);
                if (fileData.issues && Array.isArray(fileData.issues)) {
                  fileData.issues.forEach(issue => {
                    const key = `${fileData.file}:${issue.line}:${issue.category}`;
                    currentIssuesMap.set(key, issue);
                    console.log('Added issue:', key);
                  });
                }
              });
            }
            
            console.log('Total current issues:', currentIssuesMap.size);
            
            // Auto-resolve fixed issues
            let resolvedCount = 0;
            for (const comment of existingComments) {
              if (!comment.path || !comment.line) continue;
              if (comment.user.type !== 'Bot') continue;
              
              let category = 'unknown';
              if (comment.body.includes('SVELTE')) category = 'svelte-5';
              else if (comment.body.includes('ACCESSIBILITY')) category = 'accessibility';
              else if (comment.body.includes('PERFORMANCE')) category = 'performance';
              else if (comment.body.includes('SECURITY')) category = 'security';
              else if (comment.body.includes('CODE QUALITY')) category = 'code-quality';
              else if (comment.body.includes('TYPE SAFETY')) category = 'type-safety';
              
              const key = `${comment.path}:${comment.line}:${category}`;
              
              if (!currentIssuesMap.has(key)) {
                try {
                  await github.rest.pulls.createReplyForReviewComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: context.issue.number,
                    comment_id: comment.id,
                    body: '‚úÖ **Fixed!** This issue has been resolved.'
                  });
                  resolvedCount++;
                  console.log('Resolved:', key);
                } catch (e) {
                  console.log('Could not resolve:', e.message);
                }
              }
            }
            
            // POST NEW INLINE COMMENTS
            let newComments = 0;
            let failedComments = 0;
            
            if (results.issues && Array.isArray(results.issues) && results.issues.length > 0) {
              for (const fileData of results.issues) {
                console.log('\nProcessing file:', fileData.file);
                
                if (!fileData.issues || !Array.isArray(fileData.issues)) {
                  console.log('No issues array for file');
                  continue;
                }
                
                for (const issue of fileData.issues) {
                  console.log('Processing issue at line', issue.line);
                  
                  const icon = icons[issue.severity] || '‚ö™';
                  const category = (issue.category || 'issue').toUpperCase().replace(/-/g, ' ');
                  
                  let body = icon + ' **' + category + '**\n\n';
                  body += '**Problem:** ' + issue.issue + '\n\n';
                  
                  if (issue.code) {
                    body += '**Current Code:**\n```svelte\n' + issue.code + '\n```\n\n';
                  }
                  
                  if (issue.suggestion) {
                    body += '**Fixed Code:**\n```svelte\n' + issue.suggestion + '\n```\n\n';
                  }
                  
                  if (issue.impact) {
                    body += '**Why:** ' + issue.impact + '\n\n';
                  }
                  
                  body += '_Category: ' + issue.category + ' | Severity: ' + issue.severity + '_';
                  
                  console.log('Comment body:', body);
                  
                  try {
                    const response = await github.rest.pulls.createReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: context.issue.number,
                      body: body,
                      path: fileData.file,
                      line: issue.line,
                      side: 'RIGHT'
                    });
                    newComments++;
                    console.log('‚úÖ Posted comment on', fileData.file, 'line', issue.line);
                  } catch (err) {
                    failedComments++;
                    console.log('‚ùå Failed to post comment:', err.message);
                    console.log('Error details:', JSON.stringify(err, null, 2));
                    
                    // Fallback: try without line number (post as general comment)
                    try {
                      const fallbackBody = '**File:** `' + fileData.file + '` - Line ' + issue.line + '\n\n' + body;
                      await github.rest.issues.createComment({
                        issue_number: context.issue.number,
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        body: fallbackBody
                      });
                      console.log('‚úÖ Posted as general comment');
                    } catch (e2) {
                      console.log('‚ùå Fallback also failed:', e2.message);
                    }
                  }
                }
              }
            } else {
              console.log('No issues to post');
            }
            
            console.log('\nSummary:');
            console.log('- New comments posted:', newComments);
            console.log('- Failed comments:', failedComments);
            console.log('- Resolved comments:', resolvedCount);
            
            // POST REVIEW SUMMARY
            let reviewEvent = 'COMMENT';
            let reviewBody = '## ü§ñ AI Code Review\n\n';
            
            if (resolvedCount > 0) {
              reviewBody += '‚úÖ **' + resolvedCount + ' issue(s) fixed!**\n\n';
            }
            
            if (results.filesReviewed === 0) {
              reviewEvent = 'APPROVE';
              reviewBody += '‚úÖ No files changed\n';
            } else if (results.criticalCount > 0) {
              reviewEvent = 'REQUEST_CHANGES';
              reviewBody += 'üî¥ **' + results.criticalCount + ' critical issue(s)**\n\n';
            } else if (results.errorCount > 0) {
              reviewEvent = 'COMMENT';
              reviewBody += 'üü† **' + results.errorCount + ' error(s)**\n\n';
            } else if (results.warningCount > 0) {
              reviewEvent = 'APPROVE';
              reviewBody += '‚úÖ Approved (' + results.warningCount + ' warnings)\n\n';
            } else {
              reviewEvent = 'APPROVE';
              reviewBody += '‚úÖ Perfect! No issues\n\n';
            }
            
            reviewBody += '**Stats:**\n';
            reviewBody += '- Reviewed: ' + results.filesReviewed + ' files\n';
            if (newComments > 0) reviewBody += '- Inline comments: ' + newComments + '\n';
            if (failedComments > 0) reviewBody += '- Failed to post: ' + failedComments + '\n';
            if (resolvedCount > 0) reviewBody += '- Resolved: ' + resolvedCount + '\n';
            
            if (results.analytics && results.analytics.insights) {
              reviewBody += '\n---\n' + results.analytics.insights;
            }
            
            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                event: reviewEvent,
                body: reviewBody
              });
              console.log('‚úÖ Review posted:', reviewEvent);
            } catch (e) {
              console.log('‚ùå Review error:', e.message);
              
              // Fallback to issue comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: reviewBody
              });
            }
      
      - name: Save Review State
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: previous-review
          path: previous-review.json
          retention-days: 30