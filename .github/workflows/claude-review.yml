name: AI Code Review

on:
  pull_request:
    branches: [main, develop]

jobs:
  ai-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    
    steps:
      - name: Generate App Token
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
      
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
      
      - name: Fetch base branch
        run: |
          git fetch origin ${{ github.base_ref }}:refs/remotes/origin/${{ github.base_ref }}
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install
        run: npm ci
      
      - name: Download Previous Review
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: previous-review
          path: .
      
      - name: AI Review
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_EVENT_NAME: pull_request
          GITHUB_BASE_REF: ${{ github.base_ref }}
          GITHUB_HEAD_REF: ${{ github.head_ref }}
          PR_BASE_SHA: ${{ github.event.pull_request.base.sha }}
          PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: npm run ai-review || true
      
      - name: Post Comments and Auto-Resolve
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.generate-token.outputs.token }}
          script: |
            const fs = require('fs');
            let results;
            try {
              results = JSON.parse(fs.readFileSync('ai-review-results.json', 'utf8'));
            } catch (e) {
              console.log('No results');
              return;
            }
            
            const icons = {
              critical: 'ðŸ”´',
              error: 'ðŸŸ ', 
              warning: 'ðŸŸ¡',
              info: 'ðŸ”µ'
            };
            
            // Get all existing review comments from this bot
            let existingComments = [];
            try {
              const reviews = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });
              
              for (const review of reviews.data) {
                if (review.user.type === 'Bot' || review.user.login.includes('[bot]')) {
                  try {
                    const comments = await github.rest.pulls.listCommentsForReview({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: context.issue.number,
                      review_id: review.id
                    });
                    existingComments.push(...comments.data);
                  } catch (e) {
                    console.log('Could not fetch review comments');
                  }
                }
              }
            } catch (e) {
              console.log('Could not fetch reviews');
            }
            
            // Build map of current issues
            const currentIssuesMap = new Map();
            if (results.issues) {
              results.issues.forEach(fileData => {
                fileData.issues.forEach(issue => {
                  const key = `${fileData.file}:${issue.line}:${issue.category}`;
                  currentIssuesMap.set(key, issue);
                });
              });
            }
            
            // Auto-resolve fixed issues
            let resolvedCount = 0;
            for (const comment of existingComments) {
              if (!comment.path || !comment.line) continue;
              
              // Try to extract category from comment body
              let category = 'unknown';
              if (comment.body.includes('SVELTE')) category = 'svelte-5';
              else if (comment.body.includes('ACCESSIBILITY')) category = 'accessibility';
              else if (comment.body.includes('PERFORMANCE')) category = 'performance';
              else if (comment.body.includes('SECURITY')) category = 'security';
              else if (comment.body.includes('CODE QUALITY')) category = 'code-quality';
              else if (comment.body.includes('TYPE SAFETY')) category = 'type-safety';
              
              const key = `${comment.path}:${comment.line}:${category}`;
              
              // If issue no longer exists, mark as resolved
              if (!currentIssuesMap.has(key)) {
                try {
                  await github.rest.pulls.createReplyForReviewComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: context.issue.number,
                    comment_id: comment.id,
                    body: 'âœ… **Fixed!** This issue has been resolved in the latest commit.'
                  });
                  resolvedCount++;
                  console.log('Resolved:', comment.path, 'line', comment.line);
                } catch (e) {
                  console.log('Could not resolve comment:', e.message);
                }
              }
            }
            
            // POST NEW INLINE COMMENTS
            let newComments = 0;
            if (results.issues && results.issues.length > 0) {
              for (const fileData of results.issues) {
                for (const issue of fileData.issues) {
                  const icon = icons[issue.severity] || 'âšª';
                  
                  let body = icon + ' **' + (issue.category || 'issue').toUpperCase().replace(/-/g, ' ') + '**\n\n';
                  body += issue.issue + '\n\n';
                  
                  if (issue.code) {
                    body += '```svelte\n' + issue.code + '\n```\n\n';
                  }
                  
                  if (issue.suggestion) {
                    body += '**Fix:**\n```svelte\n' + issue.suggestion + '\n```\n\n';
                  }
                  
                  if (issue.impact) {
                    body += 'ðŸ’¡ ' + issue.impact;
                  }
                  
                  try {
                    await github.rest.pulls.createReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: context.issue.number,
                      body: body,
                      path: fileData.file,
                      line: issue.line,
                      side: 'RIGHT'
                    });
                    newComments++;
                  } catch (err) {
                    console.log('Failed inline comment:', err.message);
                  }
                }
              }
            }
            
            // POST REVIEW SUMMARY
            let reviewEvent = 'COMMENT';
            let reviewBody = '## ðŸ¤– AI Code Review\n\n';
            
            if (resolvedCount > 0) {
              reviewBody += 'âœ… **' + resolvedCount + ' issue(s) fixed!**\n\n';
            }
            
            if (results.filesReviewed === 0) {
              reviewEvent = 'APPROVE';
              reviewBody += 'âœ… No files changed\n';
            } else if (results.criticalCount > 0) {
              reviewEvent = 'REQUEST_CHANGES';
              reviewBody += 'ðŸ”´ **' + results.criticalCount + ' critical** - Fix required\n';
            } else if (results.errorCount > 0) {
              reviewEvent = 'COMMENT';
              reviewBody += 'ðŸŸ  **' + results.errorCount + ' error(s)**\n';
            } else if (results.warningCount > 0) {
              reviewEvent = 'APPROVE';
              reviewBody += 'âœ… Approved (' + results.warningCount + ' warnings)\n';
            } else {
              reviewEvent = 'APPROVE';
              reviewBody += 'âœ… Perfect! No issues\n';
            }
            
            reviewBody += '\n**Stats:**\n';
            reviewBody += '- Reviewed: ' + results.filesReviewed + ' files\n';
            if (newComments > 0) reviewBody += '- New comments: ' + newComments + '\n';
            if (resolvedCount > 0) reviewBody += '- Resolved: ' + resolvedCount + '\n';
            
            if (results.analytics && results.analytics.insights) {
              reviewBody += '\n---\n' + results.analytics.insights;
            }
            
            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                event: reviewEvent,
                body: reviewBody
              });
              console.log('Review posted:', reviewEvent);
            } catch (e) {
              console.log('Review error:', e.message);
            }
      
      - name: Save Review State
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: previous-review
          path: previous-review.json
          retention-days: 30