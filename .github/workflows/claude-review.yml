name: Enhanced AI Code Review

on:
  pull_request:
    branches: [main, develop]

jobs:
  ai-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    
    steps:
      - name: Checkout with history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
      
      - name: Fetch base
        run: git fetch origin ${{ github.base_ref }}:${{ github.base_ref }}
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install
        run: npm ci
      
      - name: Enhanced AI Review
        id: review
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_BASE_REF: ${{ github.base_ref }}
          GITHUB_HEAD_REF: ${{ github.head_ref }}
        run: |
          npm run ai-review || true
          echo "done=true" >> $GITHUB_OUTPUT
      
      - name: Post Review
        uses: actions/github-script@v7
        if: always() && steps.review.outputs.done
        with:
          script: |
            const fs = require('fs');
            let results;
            try {
              results = JSON.parse(fs.readFileSync('ai-review-results.json', 'utf8'));
            } catch (e) {
              return;
            }
            
            const sev = { critical: 'ðŸ”´', error: 'ðŸŸ ', warning: 'ðŸŸ¡', info: 'ðŸ”µ' };
            const lab = { critical: 'CRITICAL', error: 'ERROR', warning: 'WARNING', info: 'INFO' };
            
            if (!results.issues || results.issues.length === 0) {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                event: 'APPROVE',
                body: 'AI Review: ' + (results.filesReviewed === 0 ? 'No files changed' : 'All passed!')
              });
              return;
            }
            
            let comments = [];
            for (const fd of results.issues) {
              for (const iss of fd.issues) {
                let body = sev[iss.severity] + ' **' + lab[iss.severity] + ': ' + (iss.category || 'GENERAL').toUpperCase() + '**\n\n';
                body += '**Problem:** ' + iss.issue + '\n\n';
                if (iss.code) body += '**Code:**\n```svelte\n' + iss.code + '\n```\n\n';
                if (iss.suggestion) body += '**Fix:**\n```svelte\n' + iss.suggestion + '\n```\n\n';
                if (iss.impact) body += '**Impact:** ' + iss.impact + '\n\n';
                body += '\n_AI Review_';
                comments.push({ path: fd.file, line: iss.line, body });
              }
            }
            
            let event = 'COMMENT';
            let body = 'AI Code Review\n\n';
            
            if (results.criticalCount > 0) {
              event = 'REQUEST_CHANGES';
              body += '**CRITICAL ISSUES FOUND**\n\n';
            } else if (results.errorCount > 0) {
              body += '**Errors Found**\n\n';
            } else if (results.warningCount > 0) {
              event = 'APPROVE';
              body += '**Approved with Warnings**\n\n';
            } else {
              event = 'APPROVE';
              body += '**All Passed**\n\n';
            }
            
            body += 'Files: ' + results.filesReviewed + '\n';
            body += 'Critical: ' + results.criticalCount + '\n';
            body += 'Errors: ' + results.errorCount + '\n';
            body += 'Warnings: ' + results.warningCount + '\n';
            
            if (results.analytics && results.analytics.insights) {
              body += '\n' + results.analytics.insights;
            }
            
            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                event: event,
                body: body,
                comments: comments
              });
            } catch (err) {
              console.log('Error:', err.message);
            }